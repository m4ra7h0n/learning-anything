# 项目例子
全都是根据官网的samples学的, pdf只作为参考

# X/Open 分布式事务模型
一个 TM (事务管理器)  管理多个RM (资源管理器)
## 两阶段提交协议(XA):
1.TM通知RM准备分支事务 记录事务日志  并返回给TM结果
2.TM明确收到所有的结果再发出指令提交否则回滚

## 存在的弊端:
1.同步阻塞占用资源
2.任何一个节点失败都会回滚过于保守
3.TM故障问题 阻塞所有RM
4.局域网故障导致的 多TM  进而脑裂  使数据不一致

## 三阶段提交:
在开头增加一个询问阶段  该阶段RM不开启事务
增加超时机制

# 分布式事务的理论模型
## CAP
一致性(Consistency)
可用性(Availability)
分区容错性(Partition Tolerance)

只能同时满足CP或者AP
C和A不能同时满足

CP 放弃高可用性
AP 放弃强一致性

## BASE
CAP进化而来的理论 --> 牺牲数据强一致性获得高可用性, 但是可实现最终一致性

基本可用(Basically Available): 分区系统出现故障时允许损失一部分功能的可用性 保证核心功能的可用性
软状态(Soft State): 数据可以存在中间状态  不影响系统可用性  允许副本同步存在延迟
最终一致性(Eventually Consistent): 最终一致

# 分布式事务问题常见解决方案
## XA
两阶段提交见上文

## TCC补偿型方案
TCC (Try-Confirm-Cancel): 类似于两阶段提交

## 基于可靠性消息的最终一致性方案(支付等场景)
使用Kafka/RocketMQ/RabbitMQ
RocketMQ:
1.生产者发送给RocketMQ事务消息(此时消费者无法消费)
2.生产者执行本地事务并根据执行结果反馈给RocketMQ
3.RocketMQ收到结果后删除消息或者开放给消费者  若长时间未收到消息则向生产者产生一个查询
4.消费者消费数据并成功产生结果后返回RocketMQ确认消息  MQ删除原事务

## 最大努力通知
和消息中间件类似  消费者如果没有返回ack  则中间件会不断的推送相同内容

## AT
类似于XA  细节优化更多
三个部分(多处TC)
RM TM TC
### RM
### TM
### TC
全居锁在TC处申请

## Saga
没有两阶段提交  直接提交  遇到事务执行失败有两种处理方式
1 向后恢复 执行一系列补偿
2 重试失败子事务

# 源码
seata默认的全局隔离级别是 读未提交

@GlobalTransaction
注册的时候获取全局锁
本地事务先提交 再去获取全局锁 如果获取失败则回滚 while true 抢锁

@GlobalLock
不会开启全局事务 只会检测全局锁是否存在