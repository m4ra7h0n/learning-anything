# nacos 权限绕过修复后继续绕过
https://github.com/alibaba/nacos/issues/4701
url后面添加一个/绕过鉴权，具体原理在于添加/的url的cache未命中 导致绕过鉴权
# 修复代码
参见: https://github.com/alibaba/nacos/pull/4703/files

# 漏洞原理

默认配置
```text
nacos.core.auth.enable.userAgentAuthWhite=true

@Value("${nacos.core.auth.server.identity.key:}")
private String serverIdentityKey;

@Value(("${nacos.core.auth.server.identity.value:}"))
private String serverIdentityValue;

```

位置
com.alibaba.nacos.core.auth.AuthFilter#doFilter
```text
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
        throws IOException, ServletException {
    
    if (!authConfigs.isAuthEnabled()) {
        chain.doFilter(request, response);
        return;
    }
    
    HttpServletRequest req = (HttpServletRequest) request;
    HttpServletResponse resp = (HttpServletResponse) response;
    
    // 开发者设置为false 走else if分支
    if (authConfigs.isEnableUserAgentAuthWhite()) {
        String userAgent = WebUtils.getUserAgent(req);
        if (StringUtils.startsWith(userAgent, Constants.NACOS_SERVER_HEADER)) {
            chain.doFilter(request, response);
            return;
        }
    } else if (StringUtils.isNotBlank(authConfigs.getServerIdentityKey()) && StringUtils
            .isNotBlank(authConfigs.getServerIdentityValue())) {
        String serverIdentity = req.getHeader(authConfigs.getServerIdentityKey());
        
        // 这块复现的时候故意不匹配然后进入到下面的鉴权部分
        
        if (authConfigs.getServerIdentityValue().equals(serverIdentity)) {
            chain.doFilter(request, response);
            return;
        }
        Loggers.AUTH.warn("Invalid server identity value for {} from {}", authConfigs.getServerIdentityKey(),
                req.getRemoteHost());
    } else {
        resp.sendError(HttpServletResponse.SC_FORBIDDEN,
                "Invalid server identity key or value, Please make sure set `nacos.core.auth.server.identity.key`"
                        + " and `nacos.core.auth.server.identity.value`, or open `nacos.core.auth.enable.userAgentAuthWhite`");
        return;
    }
    
    try {
        
        // 找到让method为null的漏洞即可
        Method method = methodsCache.getMethod(req);
        
        if (method == null) {
            chain.doFilter(request, response);
            return;
        }
        
        ...
        鉴权
    }
}
```
```text
public Method getMethod(HttpServletRequest request) {

    //getPath() -> new URI(request.getRequestURI()).getPath(); 可以有/
    
    String path = getPath(request);
    if (path == null) {
        return null;
    }
    String httpMethod = request.getMethod();
    
    // /nacos替换为""
    String urlKey = httpMethod + REQUEST_PATH_SEPARATOR + path.replaceFirst(EnvUtil.getContextPath(), "");
    
    // 这块添加/后未命中返回null
    List<RequestMappingInfo> requestMappingInfos = urlLookup.get(urlKey);
    if (CollectionUtils.isEmpty(requestMappingInfos)) {
        return null;
    }
    
    List<RequestMappingInfo> matchedInfo = findMatchedInfo(requestMappingInfos, request);
    if (CollectionUtils.isEmpty(matchedInfo)) {
        return null;
    }
    RequestMappingInfo bestMatch = matchedInfo.get(0);
    if (matchedInfo.size() > 1) {
        RequestMappingInfoComparator comparator = new RequestMappingInfoComparator();
        matchedInfo.sort(comparator);
        bestMatch = matchedInfo.get(0);
        RequestMappingInfo secondBestMatch = matchedInfo.get(1);
        if (comparator.compare(bestMatch, secondBestMatch) == 0) {
            throw new IllegalStateException(
                    "Ambiguous methods mapped for '" + request.getRequestURI() + "': {" + bestMatch + ", "
                            + secondBestMatch + "}");
        }
    }
    return methods.get(bestMatch);
}
```
