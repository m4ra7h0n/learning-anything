# nacos 权限绕过修复后继续绕过
https://github.com/alibaba/nacos/issues/4701

# 验证

# exp

# 修复
version = 1.4.1 (hotfix)

# 漏洞原理

默认配置
```text
nacos.core.auth.enable.userAgentAuthWhite=true

@Value("${nacos.core.auth.server.identity.key:}")
private String serverIdentityKey;

@Value(("${nacos.core.auth.server.identity.value:}"))
private String serverIdentityValue;

```

位置
com.alibaba.nacos.core.auth.AuthFilter#doFilter
```text
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
        throws IOException, ServletException {
    
    if (!authConfigs.isAuthEnabled()) {
        chain.doFilter(request, response);
        return;
    }
    
    HttpServletRequest req = (HttpServletRequest) request;
    HttpServletResponse resp = (HttpServletResponse) response;
    
    // 开发者设置为false 走else if分支
    if (authConfigs.isEnableUserAgentAuthWhite()) {
        String userAgent = WebUtils.getUserAgent(req);
        if (StringUtils.startsWith(userAgent, Constants.NACOS_SERVER_HEADER)) {
            chain.doFilter(request, response);
            return;
        }
    } else if (StringUtils.isNotBlank(authConfigs.getServerIdentityKey()) && StringUtils
            .isNotBlank(authConfigs.getServerIdentityValue())) {
        String serverIdentity = req.getHeader(authConfigs.getServerIdentityKey());
        
        // 这块复现的时候故意不匹配然后进入到下面的鉴权部分
        
        if (authConfigs.getServerIdentityValue().equals(serverIdentity)) {
            chain.doFilter(request, response);
            return;
        }
        Loggers.AUTH.warn("Invalid server identity value for {} from {}", authConfigs.getServerIdentityKey(),
                req.getRemoteHost());
    } else {
        resp.sendError(HttpServletResponse.SC_FORBIDDEN,
                "Invalid server identity key or value, Please make sure set `nacos.core.auth.server.identity.key`"
                        + " and `nacos.core.auth.server.identity.value`, or open `nacos.core.auth.enable.userAgentAuthWhite`");
        return;
    }
    
    try {
        
        // 找到让method为null的漏洞即可
        Method method = methodsCache.getMethod(req);
        
        if (method == null) {
            chain.doFilter(request, response);
            return;
        }
        
        ...
        鉴权
    }
}
```
